# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/models/model.fft.ipynb.

# %% auto 0
__all__ = ['FFTSinusoidalForecaster', 'MovingAvgSinusoidalDecompose']

# %% ../../nbs/models/model.fft.ipynb 15
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import torch
import torch.nn as nn
from plotly.subplots import make_subplots
from scipy.fftpack import fft
import matplotlib.pyplot as plt

# %% ../../nbs/models/model.fft.ipynb 16
class FFTSinusoidalForecaster:
    def __init__(self, signal, energy_threshold=0.80, device="cpu"):
        self.device = device
        self.signal = signal.to(torch.float32).to(device)  # shape: (batch, features, seq_len)
        self.energy_threshold = energy_threshold
        self.N = self.signal.shape[-1]
        self.batch, self.features = self.signal.shape[0], self.signal.shape[1]
        self.amplitudes = None
        self.phases = None
        self.X = None
        self.reconstructed = None
        self.top_k_components = None
        self.optimal_k = None

    def fit(self):
        self.X = fft(self.signal.detach().cpu().numpy(), axis=-1)
        self.amplitudes = np.abs(self.X) / self.N
        self.phases = np.angle(self.X)

    def get_optimal_k(self):
        energy = np.cumsum(np.sort(self.amplitudes**2, axis=-1)[:, :, ::-1], axis=-1)
        total_energy = np.sum(self.amplitudes**2, axis=-1, keepdims=True)
        normalized_energy = energy / total_energy
        K = (normalized_energy < self.energy_threshold).sum(axis=-1) + 1
        return K.max().item()  # take max k across batch/features

    def _generate_component_sum(self, time_steps, indices,period=0):
        reconstructed = np.zeros((self.batch, self.features, len(time_steps)), dtype=float)
        self.top_k_components = []

        for k in indices:
            A = self.amplitudes[:, :, k]  # (batch, features)
            phi = self.phases[:, :, k]
            omega = 2 * np.pi * k / (self.N + period)
            t = np.expand_dims(time_steps, axis=(0, 1))  # (1,1,T)
            component = A[:, :, None] * np.cos(omega * t + phi[:, :, None])
            reconstructed += component
            self.top_k_components.append((k, A, component))

        return reconstructed

    def forecast(self, period=0, K=None):
        if self.X is None:
            self.fit()
        if K is None:
            K = self.get_optimal_k()
        self.optimal_k = K
        top_k_indices = np.argsort(self.amplitudes, axis=-1)[..., ::-1][..., :K]
        unique_indices = np.unique(top_k_indices)

        if period == 0:
            # In-sample seasonal reconstruction only
            t = np.arange(self.N)
            seasonal = self._generate_component_sum(t, unique_indices)
            self.reconstructed = seasonal
            return torch.tensor(seasonal, dtype=torch.float32, device=self.device)
        else:
            # Full seasonal: in-sample + forecast
            t_full = np.arange(0, self.N + period)
            seasonal_full = self._generate_component_sum(t_full, unique_indices,period)
            return torch.tensor(seasonal_full, dtype=torch.float32, device=self.device)


class MovingAvgSinusoidalDecompose(nn.Module):
    def __init__(self, kernel_size_trend, energy_threshold=0.9):
        super().__init__()
        if kernel_size_trend % 2 == 0:
            raise ValueError("kernel_size_trend must be odd")
        self.kernel_size_trend = kernel_size_trend
        self.energy_threshold = energy_threshold
        self.avg_pool = nn.AvgPool1d(kernel_size=kernel_size_trend, stride=1)

    def forward(self, x, period=0):
        if x.dim() == 2:
            x = x.unsqueeze(1)  # (B, 1, T)
        if x.dim() != 3:
            raise ValueError("Input must be 2D or 3D")

        B, C, T = x.shape

        # Trend
        pad = (self.kernel_size_trend - 1) // 2
        padded = torch.nn.functional.pad(x, (pad, pad), mode="replicate")
        trend = self.avg_pool(padded)  # (B, C, T)

        # Detrended
        detrended = x - trend

        # Seasonal (FFT)
        seasonal_model = FFTSinusoidalForecaster(
            detrended, energy_threshold=self.energy_threshold, device=x.device
        )
        seasonal = seasonal_model.forecast(period=period)
        if period > 0:
            seasonal_forecast = seasonal[..., -period:]
            seasonal = seasonal[..., :-period]
        else:
            seasonal_forecast = None

        # Noise
        noise = detrended - seasonal
        return seasonal_forecast, (trend, seasonal, noise)
